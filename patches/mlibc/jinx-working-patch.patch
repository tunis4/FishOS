diff --git mlibc-clean/.gitignore mlibc-workdir/.gitignore
index bdef4a5c..9fb1e118 100644
--- mlibc-clean/.gitignore
+++ mlibc-workdir/.gitignore
@@ -6,3 +6,6 @@
 .vscode
 compile_commands.json
 /linux-headers
+
+.cache/
+.gitignore
diff --git mlibc-clean/meson.build mlibc-workdir/meson.build
index 5541fe60..68247d2e 100644
--- mlibc-clean/meson.build
+++ mlibc-workdir/meson.build
@@ -274,6 +274,13 @@ elif host_machine.system() == 'nyaux'
 	rtld_include_dirs += include_directories('sysdeps/nyaux/include')
 	libc_include_dirs += include_directories('sysdeps/nyaux/include')
 	subdir('sysdeps/nyaux')
+elif host_machine.system() == 'fishos'
+	rtld_include_dirs += include_directories('sysdeps/fishos/include')
+	libc_include_dirs += include_directories('sysdeps/fishos/include')
+	internal_conf.set10('MLIBC_MAP_DSO_SEGMENTS', true)
+	internal_conf.set10('MLIBC_MMAP_ALLOCATE_DSO', true)
+	internal_conf.set10('MLIBC_MAP_FILE_WINDOWS', true)
+	subdir('sysdeps/fishos')
 else
 	error('No sysdeps defined for OS: ' + host_machine.system())
 endif
@@ -311,27 +318,27 @@ if linux_option
 			error('linux_kernel_headers is not set to a valid path')
 		endif
 
-		cc_search_path = run_command(meson.get_compiler('cpp', native: true), '-E', '-Wp,-v', '-xc', '/dev/null', check: true).stderr()
-		search_paths = []
-
-		search_started = false
-		foreach line : cc_search_path.strip().splitlines()
-			if not search_started and line == '#include <...> search starts here:'
-				search_started = true
-				continue
-			elif search_started and line == 'End of search list.'
-				search_started = false
-			elif search_started
-				search_paths += line.strip()
-			endif
-		endforeach
-
-		foreach path : search_paths
-			if fs.is_samepath(get_option('linux_kernel_headers'), path)
-				warning('Please install Linux kernel headers to a directory using \'make headers_install\'.')
-				error('Using system include paths for \'linux_kernel_headers\' is unsupported!')
-			endif
-		endforeach
+		# cc_search_path = run_command(meson.get_compiler('cpp', native: true), '-E', '-Wp,-v', '-xc', '/dev/null', check: true).stderr()
+		# search_paths = []
+
+		# search_started = false
+		# foreach line : cc_search_path.strip().splitlines()
+		# 	if not search_started and line == '#include <...> search starts here:'
+		# 		search_started = true
+		# 		continue
+		# 	elif search_started and line == 'End of search list.'
+		# 		search_started = false
+		# 	elif search_started
+		# 		search_paths += line.strip()
+		# 	endif
+		# endforeach
+
+		# foreach path : search_paths
+		# 	if fs.is_samepath(get_option('linux_kernel_headers'), path)
+		# 		warning('Please install Linux kernel headers to a directory using \'make headers_install\'.')
+		# 		error('Using system include paths for \'linux_kernel_headers\' is unsupported!')
+		# 	endif
+		# endforeach
 	endif
 
 	rtld_include_dirs += include_directories('options/linux/include')
diff --git mlibc-clean/options/ansi/include/math.h mlibc-workdir/options/ansi/include/math.h
index a4ffd323..240b6281 100644
--- mlibc-clean/options/ansi/include/math.h
+++ mlibc-workdir/options/ansi/include/math.h
@@ -373,6 +373,16 @@ extern int signgam;
 int finite(double __x);
 int finitef(float __x);
 
+
+
+double j0(double);
+double j1(double);
+double jn(int, double);
+
+double y0(double);
+double y1(double);
+double yn(int, double);
+
 #endif /* !__MLIBC_ABI_ONLY */
 
 #ifdef __cplusplus
diff --git mlibc-clean/options/posix/generic/netdb.cpp mlibc-workdir/options/posix/generic/netdb.cpp
index 80d0836a..f78da65a 100644
--- mlibc-clean/options/posix/generic/netdb.cpp
+++ mlibc-workdir/options/posix/generic/netdb.cpp
@@ -241,8 +241,14 @@ int getnameinfo(const struct sockaddr *__restrict addr, socklen_t addr_len,
 	}
 
 	if (serv && serv_len) {
-		__ensure("getnameinfo(): not implemented service resolution yet!");
-		__builtin_unreachable();
+		if (!(flags & NI_NUMERICSERV)) {
+			__ensure("getnameinfo(): not implemented service resolution yet!");
+			__builtin_unreachable();
+		}
+
+		uint16_t port = ntohs(reinterpret_cast<const struct sockaddr_in*>(addr)->sin_port);
+		if (snprintf(serv, serv_len, "%u", port) >= (int)serv_len)
+			return EAI_OVERFLOW;
 	}
 
 	return 0;
diff --git mlibc-clean/options/posix/generic/posix_locale.cpp mlibc-workdir/options/posix/generic/posix_locale.cpp
index f19e623e..5ca0c550 100644
--- mlibc-clean/options/posix/generic/posix_locale.cpp
+++ mlibc-workdir/options/posix/generic/posix_locale.cpp
@@ -4,8 +4,8 @@
 
 namespace {
 
-bool newlocale_seen = false;
-bool uselocale_seen = false;
+bool newlocale_seen = true;
+bool uselocale_seen = true;
 
 } // namespace
 
diff --git mlibc-clean/options/posix/generic/posix_stdlib.cpp mlibc-workdir/options/posix/generic/posix_stdlib.cpp
index 54c96d85..12ab74e8 100644
--- mlibc-clean/options/posix/generic/posix_stdlib.cpp
+++ mlibc-workdir/options/posix/generic/posix_stdlib.cpp
@@ -524,7 +524,7 @@ int grantpt(int) {
 }
 
 double strtod_l(const char *__restrict__ nptr, char ** __restrict__ endptr, locale_t) {
-	mlibc::infoLogger() << "mlibc: strtod_l ignores locale!" << frg::endlog;
+	// mlibc::infoLogger() << "mlibc: strtod_l ignores locale!" << frg::endlog;
 	return strtod(nptr, endptr);
 }
 
diff --git mlibc-clean/options/posix/include/netinet/ip_icmp.h mlibc-workdir/options/posix/include/netinet/ip_icmp.h
index c5fecd1b..5edb4ed0 100644
--- mlibc-clean/options/posix/include/netinet/ip_icmp.h
+++ mlibc-workdir/options/posix/include/netinet/ip_icmp.h
@@ -70,6 +70,8 @@ struct icmphdr {
 
 #define ICMP_ADVLENMIN (8 + sizeof(struct ip) + 8)
 
+#define ICMP_MINLEN 8
+
 struct icmp_ra_addr {
 	uint32_t ira_addr;
 	uint32_t ira_preference;
diff --git mlibc-clean/sysdeps/fishos/crt-x86_64/Scrt1.S mlibc-workdir/sysdeps/fishos/crt-x86_64/Scrt1.S
new file mode 100644
index 00000000..d0e82138
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/crt-x86_64/Scrt1.S
@@ -0,0 +1,8 @@
+.section .text
+.global _start
+_start:
+	mov %rsp, %rdi
+	lea main(%rip), %rsi
+	call __mlibc_entry
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-clean/sysdeps/fishos/crt-x86_64/crt1.S mlibc-workdir/sysdeps/fishos/crt-x86_64/crt1.S
new file mode 100644
index 00000000..6afb421d
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/crt-x86_64/crt1.S
@@ -0,0 +1,10 @@
+
+.section .text
+.global _start
+_start:
+	mov %rsp, %rdi
+	mov $main, %rsi
+	call __mlibc_entry
+
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-clean/sysdeps/fishos/crt-x86_64/crti.S mlibc-workdir/sysdeps/fishos/crt-x86_64/crti.S
new file mode 100644
index 00000000..956c6274
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/crt-x86_64/crti.S
@@ -0,0 +1,15 @@
+	.ident "x86_64-ironclad-mlibc crti"
+
+	.section .init
+	.globl	_init
+	.type	_init,@function
+_init:
+	push %rax
+
+	.section .fini
+	.globl	_fini
+	.type	_fini,@function
+_fini:
+	push %rax
+
+.section .note.GNU-stack,"",%progbits
diff --git mlibc-clean/sysdeps/fishos/crt-x86_64/crtn.S mlibc-workdir/sysdeps/fishos/crt-x86_64/crtn.S
new file mode 100644
index 00000000..d3903d1c
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/crt-x86_64/crtn.S
@@ -0,0 +1,11 @@
+.ident "x86_64-ironclad-mlibc crtn"
+
+.section .init
+	pop %rax
+	ret
+
+.section .fini
+	pop %rax
+	ret
+
+.section .note.GNU-stack,"",%progbits
diff --git mlibc-clean/sysdeps/fishos/generic/entry.cpp mlibc-workdir/sysdeps/fishos/generic/entry.cpp
new file mode 100644
index 00000000..988cb4c4
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/generic/entry.cpp
@@ -0,0 +1,61 @@
+#include <bits/ensure.h>
+#include <bits/posix/posix_signal.h>
+#include <fishos/syscall.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/debug.hpp>
+#include <mlibc/elf/startup.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+extern "C" uintptr_t *__dlapi_entrystack();
+extern "C" void __dlapi_enter(uintptr_t *entry_stack);
+
+extern char **environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard {
+	LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard() {
+	// Parse the exec() stack.
+	mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+	mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv,
+			__mlibc_stack_data.envp);
+}
+
+namespace mlibc {
+	int sys_sigentry(void *entry) {
+		int64_t ret = syscall(SYS_sigentry, (uintptr_t)entry);
+		if (ret < 0)
+			return -ret;
+		return 0;
+	}
+
+	[[noreturn]] int sys_sigreturn(ucontext_t *context, uint64_t saved_signal_mask) {
+		syscall(SYS_sigreturn, (uintptr_t)context, saved_signal_mask);
+		__builtin_unreachable();
+	}
+}
+
+[[noreturn]] static void __mlibc_sigentry(int which, siginfo_t *siginfo, uintptr_t handler, uint64_t saved_signal_mask, ucontext_t *ret_context) {
+	uintptr_t is_sigaction_mask = (uintptr_t)1 << 63;
+	bool is_sigaction = handler & is_sigaction_mask;
+	handler &= ~is_sigaction_mask;
+
+	if (is_sigaction)
+		((void (*)(int, siginfo_t *, void *))handler)(which, siginfo, ret_context);
+	else
+		((void (*)(int))handler)(which);
+
+	mlibc::sys_sigreturn(ret_context, saved_signal_mask);
+}
+
+extern "C" void __mlibc_entry(uintptr_t *entry_stack, int (*main_fn)(int argc, char *argv[], char *env[])) {
+	__dlapi_enter(entry_stack);
+	mlibc::sys_sigentry((void *)__mlibc_sigentry);
+	auto result = main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ);
+	exit(result);
+}
diff --git mlibc-clean/sysdeps/fishos/generic/filesystem.cpp mlibc-workdir/sysdeps/fishos/generic/filesystem.cpp
new file mode 100755
index 00000000..71778477
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/generic/filesystem.cpp
@@ -0,0 +1,347 @@
+#include <fishos/syscall.h>
+
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/file.h>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include <bits/ensure.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/debug.hpp>
+
+namespace mlibc {
+
+int sys_write(int fd, const void *buffer, size_t count, ssize_t *bytes_written) {
+	int64_t ret = syscall(SYS_write, fd, (uintptr_t)buffer, count);
+	if (ret < 0)
+		return -ret;
+	*bytes_written = ret;
+	return 0;
+}
+
+int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
+	int64_t ret = syscall(SYS_read, fd, (uintptr_t)buf, count);
+	if (ret < 0)
+		return -ret;
+	*bytes_read = ret;
+	return 0;
+}
+
+int sys_pwrite(int fd, const void *buffer, size_t count, off_t off, ssize_t *bytes_written) {
+	int64_t ret = syscall(SYS_pwrite, fd, (uintptr_t)buffer, count, off);
+	if (ret < 0)
+		return -ret;
+	*bytes_written = ret;
+	return 0;
+}
+
+int sys_pread(int fd, void *buf, size_t count, off_t off, ssize_t *bytes_read) {
+	int64_t ret = syscall(SYS_pread, fd, (uintptr_t)buf, count, off);
+	if (ret < 0)
+		return -ret;
+	*bytes_read = ret;
+	return 0;
+}
+
+int sys_readv(int fd, const struct iovec *iovs, int iovc, ssize_t *bytes_written) {
+	int64_t ret = syscall(SYS_readv, fd, (uintptr_t)iovs, iovc);
+	if (ret < 0)
+		return -ret;
+	*bytes_written = ret;
+	return 0;
+}
+
+int sys_writev(int fd, const struct iovec *iovs, int iovc, ssize_t *bytes_written) {
+	int64_t ret = syscall(SYS_writev, fd, (uintptr_t)iovs, iovc);
+	if (ret < 0)
+		return -ret;
+	*bytes_written = ret;
+	return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+	int64_t ret = syscall(SYS_seek, fd, offset, whence);
+	if (ret < 0)
+		return -ret;
+	*new_offset = ret;
+	return 0;
+}
+
+int sys_openat(int dirfd, const char *path, int flags, [[maybe_unused]] mode_t mode, int *fd) {
+	int64_t ret = syscall(SYS_open, dirfd, (uintptr_t)path, flags);
+	if (ret < 0)
+		return -ret;
+	*fd = ret;
+	return 0;
+}
+
+int sys_open(const char *path, int flags, mode_t mode, int *fd) {
+	return sys_openat(AT_FDCWD, path, flags, mode, fd);
+}
+
+int sys_close(int fd) {
+	int64_t ret = syscall(SYS_close, fd);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+#ifndef MLIBC_BUILDING_RTLD
+
+int sys_readlinkat(int dirfd, const char *path, void *data, size_t max_size, ssize_t *length) {
+	int64_t ret = syscall(SYS_readlink, dirfd, (uintptr_t)path, (uintptr_t)data, max_size);
+	if (ret < 0)
+		return -ret;
+	*length = ret;
+	return 0;
+}
+
+int sys_readlink(const char *path, void *data, size_t max_size, ssize_t *length) {
+	return sys_readlinkat(AT_FDCWD, path, data, max_size, length);
+}
+
+int sys_mkdir(const char *path, mode_t mode) {
+	return sys_mkdirat(AT_FDCWD, path, mode);
+}
+
+int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
+	int64_t ret = syscall(SYS_mkdir, dirfd, (uintptr_t)path, mode);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_rmdir(const char *path) {
+	return sys_unlinkat(AT_FDCWD, path, AT_REMOVEDIR);
+}
+
+int sys_unlinkat(int fd, const char *path, int flags) {
+	int64_t ret = syscall(SYS_unlink, fd, (uintptr_t)path, flags);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_open_dir(const char *path, int *fd) {
+	return sys_open(path, O_DIRECTORY, 0, fd);
+}
+
+int sys_read_entries(int fd, void *buffer, size_t max_size, size_t *bytes_read) {
+	int64_t ret = syscall(SYS_readdir, fd, (uintptr_t)buffer, max_size);
+	if (ret < 0)
+		return -ret;
+	*bytes_read = ret;
+	return 0;
+}
+
+int sys_fcntl(int fd, int request, va_list args, int *result) {
+	int64_t ret = syscall(SYS_fcntl, fd, request, va_arg(args, uint64_t));
+	if (ret < 0)
+		return -ret;
+	*result = ret;
+	return 0;
+}
+
+int sys_dup(int fd, int flags, int *newfd) {
+	__ensure(!flags);
+	int64_t ret = syscall(SYS_fcntl, fd, F_DUPFD, 0);
+	if (ret < 0)
+		return -ret;
+	*newfd = ret;
+	return 0;
+}
+
+int sys_dup2(int fd, int flags, int newfd) {
+	int64_t ret = syscall(SYS_dup, fd, newfd, flags);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
+	if (fsfdt == fsfd_target::path)
+		fd = AT_FDCWD;
+	else if (fsfdt == fsfd_target::fd)
+		flags |= AT_EMPTY_PATH;
+	else
+		__ensure(fsfdt == fsfd_target::fd_path);
+
+	int64_t ret = syscall(SYS_stat, fd, (uintptr_t)path, (uintptr_t)statbuf, flags);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_faccessat(int dirfd, const char *pathname, [[maybe_unused]] int mode, int flags) {
+	struct stat buf;
+	return sys_stat(fsfd_target::fd_path, dirfd, pathname, flags & AT_SYMLINK_NOFOLLOW, &buf);
+}
+
+int sys_access(const char *path, int mode) {
+	return sys_faccessat(AT_FDCWD, path, mode, 0);
+}
+
+int sys_pipe(int *fds, int flags) {
+	int64_t ret = syscall(SYS_pipe, (uintptr_t)fds, flags);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_rename(const char *old_path, const char *new_path) {
+	return sys_renameat(AT_FDCWD, old_path, AT_FDCWD, new_path);
+}
+
+int sys_renameat(int old_dirfd, const char *old_path, int new_dirfd, const char *new_path) {
+	int64_t ret = syscall(SYS_rename, old_dirfd, (uintptr_t)old_path, new_dirfd, (uintptr_t)new_path, 0);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_link(const char *old_path, const char *new_path) {
+	return sys_linkat(AT_FDCWD, old_path, AT_FDCWD, new_path, 0);
+}
+
+int sys_linkat(int old_dirfd, const char *old_path, int new_dirfd, const char *new_path, int flags) {
+	int64_t ret = syscall(SYS_link, old_dirfd, (uintptr_t)old_path, new_dirfd, (uintptr_t)new_path, flags);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_symlink(const char *target_path, const char *link_path) {
+	return sys_symlinkat(target_path, AT_FDCWD, link_path);
+}
+
+int sys_symlinkat(const char *target_path, int dirfd, const char *link_path) {
+	int64_t ret = syscall(SYS_symlink, (uintptr_t)target_path, dirfd, (uintptr_t)link_path);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_fadvise(int fd, off_t offset, off_t length, int advice) {
+	(void)fd; (void)offset; (void)length; (void)advice;
+	return 0;
+}
+
+int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
+    int64_t ret = syscall(SYS_ioctl, fd, request, (uintptr_t)arg);
+    if (ret < 0)
+        return -ret;
+    if (result)
+        *result = ret;
+    return 0;
+}
+
+int sys_isatty(int fd) {
+    struct winsize ws;
+    int result;
+    if (!sys_ioctl(fd, TIOCGWINSZ, &ws, &result))
+        return 0;
+    return ENOTTY;
+}
+
+int sys_tcgetattr(int fd, struct termios *attr) {
+    int result;
+    if (int e = sys_ioctl(fd, TCGETS, (void*)attr, &result); e)
+        return e;
+    return 0;
+}
+
+int sys_tcsetattr(int fd, int optional_action, const struct termios *attr) {
+    int req;
+
+    switch (optional_action) {
+	case TCSANOW: req = TCSETS; break;
+	case TCSADRAIN: req = TCSETSW; break;
+	case TCSAFLUSH: req = TCSETSF; break;
+	default: return EINVAL;
+	}
+
+	if (int e = sys_ioctl(fd, req, (void*)attr, nullptr); e)
+		return e;
+
+	return 0;
+}
+
+int sys_fsync(int) {
+	mlibc::infoLogger() << "mlibc: fsync is a stub" << frg::endlog;
+	return 0;
+}
+
+int sys_fdatasync(int) {
+	mlibc::infoLogger() << "mlibc: fdatasync is a stub" << frg::endlog;
+	return 0;
+}
+
+int sys_chmod(const char *pathname, mode_t mode) {
+	return sys_fchmodat(AT_FDCWD, pathname, mode, 0);
+}
+
+int sys_fchmod(int fd, mode_t mode) {
+	return sys_fchmodat(fd, "", mode, AT_EMPTY_PATH);
+}
+
+int sys_fchmodat([[maybe_unused]] int fd, [[maybe_unused]] const char *pathname, [[maybe_unused]] mode_t mode, [[maybe_unused]] int flags) {
+	mlibc::infoLogger() << "mlibc: fchmodat is a stub" << frg::endlog;
+	return 0;
+}
+
+int sys_flock(int fd, int options) {
+	struct flock lock;
+	lock.l_whence = SEEK_SET;
+	lock.l_start = 0;
+	lock.l_len = (off_t)((uint64_t)-1);
+	lock.l_pid = sys_getpid();
+
+	switch (options & ~(LOCK_NB)) {
+	case LOCK_SH: lock.l_type = F_RDLCK; break;
+	case LOCK_EX: lock.l_type = F_WRLCK; break;
+	case LOCK_UN: lock.l_type = F_UNLCK; break;
+	default: return EINVAL;
+	}
+
+	int command = (options & LOCK_NB) ? F_SETLK : F_SETLKW;
+	int64_t ret = syscall(SYS_fcntl, fd, command, (uintptr_t)&lock);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_umask(mode_t mode, mode_t *old) {
+	*old = syscall(SYS_umask, mode);
+	return 0;
+}
+
+int sys_inotify_create(int flags, int *fd) {
+	int64_t ret = syscall(SYS_inotify_create, flags);
+	if (ret < 0)
+		return -ret;
+	*fd = ret;
+	return 0;
+}
+
+int sys_inotify_add_watch(int ifd, const char *path, uint32_t mask, int *wd) {
+	int64_t ret = syscall(SYS_inotify_add_watch, ifd, (uintptr_t)path, mask);
+	if (ret < 0)
+		return -ret;
+	*wd = ret;
+	return 0;
+}
+
+int sys_inotify_rm_watch(int ifd, int wd) {
+	int64_t ret = syscall(SYS_inotify_rm_watch, ifd, wd);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+#endif
+
+}
diff --git mlibc-clean/sysdeps/fishos/generic/generic.cpp mlibc-workdir/sysdeps/fishos/generic/generic.cpp
new file mode 100644
index 00000000..61c29aaa
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/generic/generic.cpp
@@ -0,0 +1,548 @@
+#include <fishos/syscall.h>
+#include <stddef.h>
+#include <bits/ensure.h>
+#include <abi-bits/pid_t.h>
+#include <abi-bits/random.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/thread-entry.hpp>
+#include <stdio.h>
+#include <errno.h>
+#include <sys/resource.h>
+#include <sys/ioctl.h>
+#include <linux/futex.h>
+
+namespace mlibc {
+
+int sys_tcb_set(void *pointer) {
+	syscall(SYS_set_fs_base, (uintptr_t)pointer);
+	return 0;
+}
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) {
+	int64_t ret = syscall(SYS_mmap, (uintptr_t)hint, size, prot, flags, fd, offset);
+	if (ret < 0)
+		return -ret;
+	*window = (void*)ret;
+	return 0;
+}
+
+int sys_vm_unmap(void *pointer, size_t size) {
+	int64_t ret = syscall(SYS_munmap, (uintptr_t)pointer, size);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_vm_protect(void *pointer, size_t size, int prot) {
+	int64_t ret = syscall(SYS_mprotect, (uintptr_t)pointer, size, prot);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_anon_allocate(size_t size, void **pointer) {
+	return sys_vm_map(nullptr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, pointer);
+}
+
+int sys_anon_free(void *pointer, size_t size) {
+	return sys_vm_unmap(pointer, size);
+}
+
+void sys_libc_panic() {
+	sys_libc_log("mlibc panic!");
+	__builtin_trap();
+	for(;;);
+}
+
+void sys_libc_log(const char *msg) {
+	int len = strlen(msg);
+	ssize_t written;
+	sys_write(2, msg, len, &written);
+	sys_write(2, "\n", 1, &written);
+}
+
+int sys_futex_wait(int *pointer, int expected, const struct timespec *timeout) {
+	int64_t ret = syscall(SYS_futex, (uintptr_t)pointer, FUTEX_WAIT, expected, (uintptr_t)timeout);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_futex_wake(int *pointer) {
+	int64_t ret = syscall(SYS_futex, (uintptr_t)pointer, FUTEX_WAKE, INT_MAX);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+#ifndef MLIBC_BUILDING_RTLD
+
+[[noreturn]] void sys_thread_exit() {
+	syscall(SYS_thread_exit);
+	__builtin_unreachable();
+}
+
+extern "C" void __mlibc_start_thread();
+
+int sys_clone([[maybe_unused]] void *tcb, pid_t *tid_out, void *stack) {
+	int64_t ret = syscall(SYS_thread_spawn, (uintptr_t)__mlibc_start_thread, (uintptr_t)stack);
+	if (ret < 0)
+		return -ret;
+	*tid_out = ret;
+	return 0;
+}
+
+int sys_thread_getname(void *tcb, char *name, size_t size) {
+	auto t = reinterpret_cast<Tcb*>(tcb);
+	int64_t ret = syscall(SYS_thread_getname, t->tid, (uintptr_t)name, size);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_thread_setname(void *tcb, const char *name) {
+	auto t = reinterpret_cast<Tcb*>(tcb);
+	int64_t ret = syscall(SYS_thread_setname, t->tid, (uintptr_t)name);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_ppoll(struct pollfd *fds, nfds_t nfds, const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
+	int64_t ret = syscall(SYS_poll, (uintptr_t)fds, nfds, (uintptr_t)timeout, (uintptr_t)sigmask);
+	if (ret < 0)
+		return -ret;
+	*num_events = ret;
+	return 0;
+}
+
+int sys_poll(struct pollfd *fds, nfds_t count, int timeout, int *num_events) {
+	struct timespec ts;
+	ts.tv_sec = timeout / 1000;
+	ts.tv_nsec = (timeout % 1000) * 1000000;
+	return sys_ppoll(fds, count, timeout < 0 ? NULL : &ts, NULL, num_events);
+}
+
+int sys_pselect(int nfds, fd_set *read_set, fd_set *write_set, fd_set *except_set, const struct timespec *timeout, const sigset_t *sigmask, int *num_events) {
+	struct pollfd *fds = (struct pollfd *)calloc(nfds, sizeof(struct pollfd));
+	if (fds == NULL)
+		return ENOMEM;
+
+	for (int i = 0; i < nfds; i++) {
+		struct pollfd *fd = &fds[i];
+
+		if (read_set && FD_ISSET(i, read_set)) {
+			fd->events |= POLLIN;
+		}
+		if (write_set && FD_ISSET(i, write_set)) {
+			fd->events |= POLLOUT;
+		}
+		if (except_set && FD_ISSET(i, except_set)) {
+			fd->events |= POLLPRI;
+		}
+
+		if (!fd->events) {
+			fd->fd = -1;
+			continue;
+		}
+		fd->fd = i;
+	}
+
+	int ret = sys_ppoll(fds, nfds, timeout, sigmask, num_events);
+	if (ret != 0) {
+		free(fds);
+		return ret;
+	}
+
+	fd_set res_read_set, res_write_set, res_except_set;
+	FD_ZERO(&res_read_set);
+	FD_ZERO(&res_write_set);
+	FD_ZERO(&res_except_set);
+
+	for (int i = 0; i < nfds; i++) {
+		struct pollfd *fd = &fds[i];
+
+		if (read_set && FD_ISSET(i, read_set) && (fd->revents & (POLLIN | POLLERR | POLLHUP)) != 0)
+			FD_SET(i, &res_read_set);
+		if (write_set && FD_ISSET(i, write_set) && (fd->revents & (POLLOUT | POLLERR | POLLHUP)) != 0)
+			FD_SET(i, &res_write_set);
+		if (except_set && FD_ISSET(i, except_set) && (fd->revents & POLLPRI) != 0) 
+			FD_SET(i, &res_except_set);
+	}
+
+	free(fds);
+	if (read_set)
+		*read_set = res_read_set;
+	if (write_set)
+		*write_set = res_write_set;
+	if (except_set)
+		*except_set = res_except_set;
+
+	return 0;
+}
+
+int sys_isatty(int fd) {
+	if (fd == 0 || fd == 1 || fd == 2)
+		return 0;
+	return ENOTTY;
+}
+
+pid_t sys_gettid() {
+	return syscall(SYS_gettid);
+}
+
+pid_t sys_getpid() {
+	return syscall(SYS_getpid);
+}
+
+pid_t sys_getppid() {
+	return syscall(SYS_getppid);
+}
+
+int sys_getpgid(pid_t pid, pid_t *pgid) {
+	int64_t ret = syscall(SYS_getpgid, pid);
+	if (ret < 0)
+		return -ret;
+	*pgid = ret;
+	return 0;
+}
+
+int sys_setpgid(pid_t pid, pid_t pgid) {
+	int64_t ret = syscall(SYS_setpgid, pid, pgid);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_getsid(pid_t pid, pid_t *sid) {
+	int64_t ret = syscall(SYS_getsid, pid);
+	if (ret < 0)
+		return -ret;
+	*sid = ret;
+	return 0;
+}
+
+int sys_setsid(pid_t *sid) {
+	int64_t ret = syscall(SYS_setsid);
+	if (ret < 0)
+		return -ret;
+	*sid = ret;
+	return 0;
+}
+
+uid_t sys_getuid() {
+	return 0;
+}
+
+uid_t sys_geteuid() {
+	return 0;
+}
+
+gid_t sys_getgid() {
+	return 0;
+}
+
+int sys_setgid(gid_t) {
+	return 0;
+}
+
+gid_t sys_getegid() {
+	return 0;
+}
+
+int sys_getresuid(uid_t *ruid, uid_t *euid, uid_t *suid) {
+	if (ruid)
+		*ruid = sys_getuid();
+	if (euid)
+		*euid = sys_geteuid();
+	if (suid)
+		*suid = sys_getuid();
+	return 0;
+}
+
+int sys_getresgid(uid_t *rgid, uid_t *egid, uid_t *sgid) {
+	if (rgid)
+		*rgid = sys_getgid();
+	if (egid)
+		*egid = sys_getegid();
+	if (sgid)
+		*sgid = sys_getgid();
+	return 0;
+}
+
+void sys_exit(int status) {
+	syscall(SYS_exit, status);
+	__builtin_unreachable();
+}
+
+int sys_getcwd(char *buffer, size_t size) {
+	int64_t ret = syscall(SYS_getcwd, (uintptr_t)buffer, size);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_chdir(const char *path) {
+	int64_t ret = syscall(SYS_chdir, (uintptr_t)path);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_fchdir(int fd) {
+	int64_t ret = syscall(SYS_fchdir, fd);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+void sys_yield() {
+	syscall(SYS_sched_yield);
+}
+
+int sys_sleep(time_t *secs, long *nanos) {
+	struct timespec req = {
+		.tv_sec = *secs,
+		.tv_nsec = *nanos
+	};
+	struct timespec rem = {};
+
+	int64_t ret = syscall(SYS_sleep, (uintptr_t)&req, (uintptr_t)&rem);
+	if (ret < 0)
+		return -ret;
+
+	*secs = rem.tv_sec;
+	*nanos = rem.tv_nsec;
+	return 0;
+}
+
+int sys_clock_get(int clock, time_t *secs, long *nanos) {
+	struct timespec tp = {};
+	int64_t ret = syscall(SYS_clock_gettime, clock, (uintptr_t)&tp);
+	if (ret < 0)
+		return -ret;
+	*secs = tp.tv_sec;
+	*nanos = tp.tv_nsec;
+	return 0;
+}
+
+int sys_clock_getres(int clock, time_t *secs, long *nanos) {
+	struct timespec res = {};
+	int64_t ret = syscall(SYS_clock_getres, clock, (uintptr_t)&res);
+	if (ret < 0)
+		return -ret;
+	*secs = res.tv_sec;
+	*nanos = res.tv_nsec;
+	return 0;
+}
+
+int sys_fork(pid_t *child) {
+	int64_t ret = syscall(SYS_fork);
+	if (ret < 0)
+		return -ret;
+	*child = ret;
+	return 0;
+}
+
+int sys_execve(const char *path, char *const argv[], char *const envp[]) {
+	return -syscall(SYS_execve, (uintptr_t)path, (uintptr_t)argv, (uintptr_t)envp);
+}
+
+int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
+	if (ru) {
+		mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported" << frg::endlog;
+		return ENOSYS;
+	}
+
+	int64_t ret = syscall(SYS_waitpid, pid, (uintptr_t)status, flags);
+	if (ret < 0)
+		return -ret;
+	*ret_pid = ret;
+	return 0;
+}
+
+int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve) {
+	int64_t ret = syscall(SYS_sigmask, how, (uintptr_t)set, (uintptr_t)retrieve);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {
+	int64_t ret = syscall(SYS_sigaction, signum, (uintptr_t)act, (uintptr_t)oldact);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_sigaltstack(const stack_t *signal_stack, stack_t *old_signal_stack) {
+	int64_t ret = syscall(SYS_sigaltstack, (uintptr_t)signal_stack, (uintptr_t)old_signal_stack);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_kill(pid_t pid, int signal) {
+	int64_t ret = syscall(SYS_kill, pid, signal);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_tgkill(int, int tid, int number) {
+	return sys_kill(tid, number);
+}
+
+int sys_getcpu(int *cpu) {
+	*cpu = 0;
+	return 0;
+}
+
+int sys_getaffinity([[maybe_unused]] pid_t pid, size_t cpusetsize, cpu_set_t *mask) {
+	memset(mask, 0, cpusetsize);
+	mask->__bits[0] = 1;
+	return 0;
+}
+
+int sys_sysinfo(struct sysinfo *info) {
+	int64_t ret = syscall(SYS_sysinfo, (uintptr_t)info);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_gethostname(char *buffer, size_t bufsize) {
+	struct utsname utsname;
+	if (int err = sys_uname(&utsname))
+		return err;
+	if (strlen(utsname.nodename) >= bufsize)
+		return ENAMETOOLONG;
+	strncpy(buffer, utsname.nodename, bufsize);
+	return 0;
+}
+
+int sys_uname(struct utsname *buf) {
+	int64_t ret = syscall(SYS_uname, (uintptr_t)buf);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_ptsname(int fd, char *buffer, size_t length) {
+	int index;
+	if (int e = sys_ioctl(fd, TIOCGPTN, &index, nullptr); e)
+		return e;
+	if ((size_t)snprintf(buffer, length, "/dev/pts/%d", index) >= length)
+		return ERANGE;
+	return 0;
+}
+
+int sys_unlockpt(int fd) {
+	int unlock = 0;
+	if (int e = sys_ioctl(fd, TIOCSPTLCK, &unlock, nullptr); e)
+		return e;
+	return 0;
+}
+
+int sys_ttyname(int fd, char *buffer, size_t length) {
+	int e = sys_ptsname(fd, buffer, length);
+	if (e == 0 || e == ERANGE)
+		return e;
+	if (!sys_isatty(fd))
+		return ENOTTY;
+	if ((size_t)snprintf(buffer, length, "/dev/console") >= length)
+		return ERANGE;
+	return 0;
+}
+
+int sys_setitimer([[maybe_unused]] int which, [[maybe_unused]] const struct itimerval *new_value, [[maybe_unused]] struct itimerval *old_value) {
+	return 0;
+}
+
+int sys_getitimer([[maybe_unused]] int which, [[maybe_unused]] struct itimerval *curr_value) {
+	return 0;
+}
+
+int sys_getrandom(void *buffer, size_t length, int flags, ssize_t *bytes_written) {
+	const char *open_pathname = (flags & GRND_RANDOM) ? "/dev/random" : "/dev/urandom";
+	int open_flags = O_RDONLY;
+	if (flags & GRND_NONBLOCK)
+		open_flags |= O_NONBLOCK;
+
+	int fd;
+	int error = sys_open(open_pathname, open_flags, 0, &fd);
+	if (error)
+		return error;
+
+	error = sys_read(fd, buffer, length, bytes_written);
+	sys_close(fd);
+	return error;
+}
+
+int sys_getentropy(void *buffer, size_t length) {
+	ssize_t written;
+	return sys_getrandom(buffer, length, 0, &written);
+}
+
+int sys_getrlimit(int resource, struct rlimit *limit) {
+	switch (resource) {
+	case RLIMIT_NOFILE:
+		limit->rlim_cur = 1024;
+		limit->rlim_max = 1024;
+		return 0;
+	case RLIMIT_NPROC:
+		limit->rlim_cur = 126935;
+		limit->rlim_max = 126935;
+		return 0;
+	default:
+		mlibc::infoLogger() << "mlibc: getrlimit is incomplete" << frg::endlog;
+		return EINVAL;
+	}
+}
+
+int sys_sysconf(int num, long *ret) {
+	switch(num) {
+	case _SC_OPEN_MAX: {
+		struct rlimit ru;
+		if (int e = sys_getrlimit(RLIMIT_NOFILE, &ru); e)
+			return e;
+		*ret = (ru.rlim_cur == RLIM_INFINITY) ? -1 : ru.rlim_cur;
+	} break;
+	case _SC_NPROCESSORS_CONF:
+	case _SC_NPROCESSORS_ONLN: {
+		cpu_set_t set;
+		CPU_ZERO(&set);
+		if (int e = sys_getaffinity(0, sizeof(set), &set); e)
+			return e;
+		*ret = CPU_COUNT(&set);
+	} break;
+	case _SC_CHILD_MAX: {
+		struct rlimit ru;
+		if (int e = sys_getrlimit(RLIMIT_NPROC, &ru); e)
+			return e;
+		*ret = (ru.rlim_cur == RLIM_INFINITY) ? -1 : ru.rlim_cur;
+	} break;
+	case _SC_LINE_MAX: {
+		*ret = LINE_MAX;
+	} break;
+	case _SC_IOV_MAX: {
+		*ret = IOV_MAX;
+	} break;
+	default:
+		return EINVAL;
+	}
+	return 0;
+}
+
+int sys_eventfd_create(unsigned int initval, int flags, int *fd) {
+	int64_t ret = syscall(SYS_eventfd_create, initval, flags);
+	if (ret < 0)
+		return -ret;
+	*fd = ret;
+	return 0;
+}
+
+#endif
+
+}
diff --git mlibc-clean/sysdeps/fishos/generic/socket.cpp mlibc-workdir/sysdeps/fishos/generic/socket.cpp
new file mode 100644
index 00000000..5ddb2a22
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/generic/socket.cpp
@@ -0,0 +1,130 @@
+#include <fishos/syscall.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/thread-entry.hpp>
+#include <mlibc/debug.hpp>
+#include <abi-bits/in.h>
+#include <abi-bits/errno.h>
+#include <unistd.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+
+namespace mlibc {
+
+int sys_socket(int domain, int type, int protocol, int *fd) {
+	int64_t ret = syscall(SYS_socket, domain, type, protocol);
+	if (ret < 0)
+		return -ret;
+	*fd = ret;
+	return 0;
+}
+
+int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) {
+	int64_t ret = syscall(SYS_bind, fd, (uintptr_t)addr_ptr, addr_length);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length) {
+	int64_t ret = syscall(SYS_connect, fd, (uintptr_t)addr_ptr, addr_length);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_listen(int fd, int backlog) {
+	int64_t ret = syscall(SYS_listen, fd, backlog);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_accept(int fd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length, int flags) {
+	int64_t ret = syscall(SYS_accept, fd, (uintptr_t)addr_ptr, (uintptr_t)addr_length, flags);
+	if (ret < 0)
+		return -ret;
+	*newfd = ret;
+	return 0;
+}
+
+int sys_msg_send(int fd, const struct msghdr *hdr, int flags, ssize_t *length) {
+	int64_t ret = syscall(SYS_sendmsg, fd, (uintptr_t)hdr, flags);
+	if (ret < 0)
+		return -ret;
+	*length = ret;
+	return 0;
+}
+
+int sys_msg_recv(int fd, struct msghdr *hdr, int flags, ssize_t *length) {
+	int64_t ret = syscall(SYS_recvmsg, fd, (uintptr_t)hdr, flags);
+	if (ret < 0)
+		return -ret;
+	*length = ret;
+	return 0;
+}
+
+int sys_socketpair(int domain, int type, int protocol, int *fds) {
+	int64_t ret = syscall(SYS_socketpair, domain, type, protocol, (uintptr_t)fds);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size) {
+	int64_t ret = syscall(SYS_getsockopt, fd, layer, number, (uintptr_t)buffer, (uintptr_t)size);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size) {
+	int64_t ret = syscall(SYS_setsockopt, fd, layer, number, (uintptr_t)buffer, size);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_sockname(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
+	int64_t ret = syscall(SYS_getsockname, fd, (uintptr_t)addr_ptr, (uintptr_t)&max_addr_length);
+	if (ret < 0)
+		return -ret;
+	*actual_length = max_addr_length;
+	return 0;
+}
+
+int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length) {
+	int64_t ret = syscall(SYS_getpeername, fd, (uintptr_t)addr_ptr, (uintptr_t)&max_addr_length);
+	if (ret < 0)
+		return -ret;
+	*actual_length = max_addr_length;
+	return 0;
+}
+
+int sys_shutdown(int sockfd, int how) {
+	int64_t ret = syscall(SYS_shutdown, sockfd, how);
+	if (ret < 0)
+		return -ret;
+	return 0;
+}
+
+int sys_if_nametoindex(const char *name, unsigned int *ret) {
+	int fd = 0;
+	int r = sys_socket(AF_INET, SOCK_DGRAM | SOCK_CLOEXEC, AF_UNSPEC, &fd);
+
+	if (r)
+		return r;
+
+	struct ifreq ifr;
+	strncpy(ifr.ifr_name, name, sizeof ifr.ifr_name);
+
+	r = sys_ioctl(fd, SIOCGIFINDEX, &ifr, NULL);
+	close(fd);
+
+	if (r)
+		return r;
+
+	*ret = ifr.ifr_ifindex;
+	return 0;
+}
+
+} // namespace mlibc
diff --git mlibc-clean/sysdeps/fishos/generic/thread.cpp mlibc-workdir/sysdeps/fishos/generic/thread.cpp
new file mode 100644
index 00000000..60bc3b4d
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/generic/thread.cpp
@@ -0,0 +1,51 @@
+#include <mlibc/thread-entry.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <mlibc/tcb.hpp>
+#include <bits/ensure.h>
+#include <sys/mman.h>
+#include <stdint.h>
+#include <stddef.h>
+
+extern "C" void __mlibc_enter_thread(void *entry, void *user_arg, Tcb *tcb) {
+	// Wait until our parent sets up the TID.
+	while (!__atomic_load_n(&tcb->tid, __ATOMIC_RELAXED))
+		mlibc::sys_futex_wait(&tcb->tid, 0, nullptr);
+
+	if (mlibc::sys_tcb_set(tcb))
+		__ensure(!"sys_tcb_set() failed");
+
+	tcb->invokeThreadFunc(entry, user_arg);
+
+	__atomic_store_n(&tcb->didExit, 1, __ATOMIC_RELEASE);
+	mlibc::sys_futex_wake(&tcb->didExit);
+
+	mlibc::sys_thread_exit();
+}
+
+namespace mlibc {
+
+static constexpr size_t default_stacksize = 0x200000;
+
+int sys_prepare_stack(void **stack, void *entry, void *user_arg, void *tcb, size_t *stack_size, size_t *guard_size, void **stack_base) {
+	if (!*stack_size)
+		*stack_size = default_stacksize;
+	*guard_size = 0;
+
+	if (*stack) {
+		*stack_base = *stack;
+	} else {
+		*stack_base = mmap(nullptr, *stack_size,
+						PROT_READ | PROT_WRITE,
+						MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	}
+	
+	uintptr_t *sp = reinterpret_cast<uintptr_t *>(reinterpret_cast<uintptr_t>(*stack_base) + *stack_size);
+
+	*--sp = reinterpret_cast<uintptr_t>(tcb);
+	*--sp = reinterpret_cast<uintptr_t>(user_arg);
+	*--sp = reinterpret_cast<uintptr_t>(entry);
+	*stack = reinterpret_cast<void*>(sp);
+	return 0;
+}
+
+} //namespace mlibc
diff --git mlibc-clean/sysdeps/fishos/generic/thread_entry.S mlibc-workdir/sysdeps/fishos/generic/thread_entry.S
new file mode 100644
index 00000000..f75d698d
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/generic/thread_entry.S
@@ -0,0 +1,10 @@
+.section .text
+.global __mlibc_start_thread
+__mlibc_start_thread:
+	pop %rdi
+	pop %rsi
+	pop %rdx
+	call __mlibc_enter_thread
+
+.section .note.GNU-stack,"",%progbits
+
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/access.h mlibc-workdir/sysdeps/fishos/include/abi-bits/access.h
new file mode 120000
index 00000000..cb839316
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/access.h
@@ -0,0 +1 @@
+../../../../abis/linux/access.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/auxv.h mlibc-workdir/sysdeps/fishos/include/abi-bits/auxv.h
new file mode 120000
index 00000000..c43f8786
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/linux/auxv.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/blkcnt_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/blkcnt_t.h
new file mode 120000
index 00000000..0b0ec270
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blkcnt_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/blksize_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/blksize_t.h
new file mode 120000
index 00000000..7dc8d7cf
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blksize_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/clockid_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/clockid_t.h
new file mode 120000
index 00000000..6a42da56
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/clockid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/clockid_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/dev_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/dev_t.h
new file mode 120000
index 00000000..bca881e9
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/dev_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/epoll.h mlibc-workdir/sysdeps/fishos/include/abi-bits/epoll.h
new file mode 120000
index 00000000..eb4b76dc
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/epoll.h
@@ -0,0 +1 @@
+../../../../abis/linux/epoll.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/errno.h mlibc-workdir/sysdeps/fishos/include/abi-bits/errno.h
new file mode 120000
index 00000000..6e507def
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/linux/errno.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/fcntl.h mlibc-workdir/sysdeps/fishos/include/abi-bits/fcntl.h
new file mode 120000
index 00000000..463e2c95
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/linux/fcntl.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/fsblkcnt_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/fsblkcnt_t.h
new file mode 120000
index 00000000..898dfb2f
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/fsblkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsblkcnt_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/fsfilcnt_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/fsfilcnt_t.h
new file mode 120000
index 00000000..791755c9
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/fsfilcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsfilcnt_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/gid_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/gid_t.h
new file mode 120000
index 00000000..abce6d69
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/gid_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/in.h mlibc-workdir/sysdeps/fishos/include/abi-bits/in.h
new file mode 120000
index 00000000..418d1d5c
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/linux/in.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/ino_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/ino_t.h
new file mode 120000
index 00000000..4c20aca2
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/ino_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/inotify.h mlibc-workdir/sysdeps/fishos/include/abi-bits/inotify.h
new file mode 120000
index 00000000..b5cb2823
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/inotify.h
@@ -0,0 +1 @@
+../../../../abis/linux/inotify.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/ioctls.h mlibc-workdir/sysdeps/fishos/include/abi-bits/ioctls.h
new file mode 120000
index 00000000..595106b6
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/ioctls.h
@@ -0,0 +1 @@
+../../../../abis/linux/ioctls.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/ipc.h mlibc-workdir/sysdeps/fishos/include/abi-bits/ipc.h
new file mode 120000
index 00000000..2c7ffc4c
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/ipc.h
@@ -0,0 +1 @@
+../../../../abis/linux/ipc.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/limits.h mlibc-workdir/sysdeps/fishos/include/abi-bits/limits.h
new file mode 120000
index 00000000..6c88db2e
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/limits.h
@@ -0,0 +1 @@
+../../../../abis/linux/limits.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/mode_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/mode_t.h
new file mode 120000
index 00000000..5d78fdfc
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/mode_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/mqueue.h mlibc-workdir/sysdeps/fishos/include/abi-bits/mqueue.h
new file mode 120000
index 00000000..fa87b078
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/mqueue.h
@@ -0,0 +1 @@
+../../../../abis/linux/mqueue.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/msg.h mlibc-workdir/sysdeps/fishos/include/abi-bits/msg.h
new file mode 120000
index 00000000..f402b493
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/msg.h
@@ -0,0 +1 @@
+../../../../abis/linux/msg.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/nlink_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/nlink_t.h
new file mode 120000
index 00000000..bb3b625c
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/nlink_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/packet.h mlibc-workdir/sysdeps/fishos/include/abi-bits/packet.h
new file mode 120000
index 00000000..998ef1ab
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/packet.h
@@ -0,0 +1 @@
+../../../../abis/linux/packet.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/pid_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/pid_t.h
new file mode 120000
index 00000000..baa90f6a
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/pid_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/poll.h mlibc-workdir/sysdeps/fishos/include/abi-bits/poll.h
new file mode 120000
index 00000000..8ea6a0a3
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/poll.h
@@ -0,0 +1 @@
+../../../../abis/linux/poll.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/ptrace.h mlibc-workdir/sysdeps/fishos/include/abi-bits/ptrace.h
new file mode 120000
index 00000000..b2517b2c
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/ptrace.h
@@ -0,0 +1 @@
+../../../../abis/linux/ptrace.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/random.h mlibc-workdir/sysdeps/fishos/include/abi-bits/random.h
new file mode 120000
index 00000000..83fc3d96
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/random.h
@@ -0,0 +1 @@
+../../../../abis/linux/random.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/reboot.h mlibc-workdir/sysdeps/fishos/include/abi-bits/reboot.h
new file mode 120000
index 00000000..77013a41
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/reboot.h
@@ -0,0 +1 @@
+../../../../abis/linux/reboot.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/resource.h mlibc-workdir/sysdeps/fishos/include/abi-bits/resource.h
new file mode 120000
index 00000000..88d74025
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/linux/resource.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/rlim_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/rlim_t.h
new file mode 120000
index 00000000..e92eb5fb
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/rlim_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/rlim_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/seek-whence.h mlibc-workdir/sysdeps/fishos/include/abi-bits/seek-whence.h
new file mode 120000
index 00000000..df7bccf0
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/linux/seek-whence.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/shm.h mlibc-workdir/sysdeps/fishos/include/abi-bits/shm.h
new file mode 120000
index 00000000..067d8c4f
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/shm.h
@@ -0,0 +1 @@
+../../../../abis/linux/shm.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/sigevent.h mlibc-workdir/sysdeps/fishos/include/abi-bits/sigevent.h
new file mode 120000
index 00000000..83d069b5
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/sigevent.h
@@ -0,0 +1 @@
+../../../../abis/linux/sigevent.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/signal.h mlibc-workdir/sysdeps/fishos/include/abi-bits/signal.h
new file mode 120000
index 00000000..4dcb0b7c
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/signal.h
@@ -0,0 +1 @@
+../../../../abis/linux/signal.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/sigval.h mlibc-workdir/sysdeps/fishos/include/abi-bits/sigval.h
new file mode 120000
index 00000000..ccd43a55
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/sigval.h
@@ -0,0 +1 @@
+../../../../abis/linux/sigval.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/socket.h mlibc-workdir/sysdeps/fishos/include/abi-bits/socket.h
new file mode 120000
index 00000000..f1dc016e
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/linux/socket.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/socklen_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/socklen_t.h
new file mode 120000
index 00000000..41f3b11f
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/socklen_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/socklen_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/stat.h mlibc-workdir/sysdeps/fishos/include/abi-bits/stat.h
new file mode 120000
index 00000000..1f63b41f
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/linux/stat.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/statfs.h mlibc-workdir/sysdeps/fishos/include/abi-bits/statfs.h
new file mode 120000
index 00000000..e3d202f5
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/statfs.h
@@ -0,0 +1 @@
+../../../../abis/linux/statfs.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/statvfs.h mlibc-workdir/sysdeps/fishos/include/abi-bits/statvfs.h
new file mode 120000
index 00000000..1fc80c2a
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/statvfs.h
@@ -0,0 +1 @@
+../../../../abis/linux/statvfs.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/statx.h mlibc-workdir/sysdeps/fishos/include/abi-bits/statx.h
new file mode 120000
index 00000000..8702a1d0
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/statx.h
@@ -0,0 +1 @@
+../../../../abis/linux/statx.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/suseconds_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/suseconds_t.h
new file mode 120000
index 00000000..9ed65977
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/suseconds_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/suseconds_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/termios.h mlibc-workdir/sysdeps/fishos/include/abi-bits/termios.h
new file mode 120000
index 00000000..ee8f0b09
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/linux/termios.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/time.h mlibc-workdir/sysdeps/fishos/include/abi-bits/time.h
new file mode 120000
index 00000000..2a026257
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/linux/time.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/uid_t.h mlibc-workdir/sysdeps/fishos/include/abi-bits/uid_t.h
new file mode 120000
index 00000000..b3067778
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/uid_t.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/utmp-defines.h mlibc-workdir/sysdeps/fishos/include/abi-bits/utmp-defines.h
new file mode 120000
index 00000000..86176435
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/utmp-defines.h
@@ -0,0 +1 @@
+../../../../abis/linux/utmp-defines.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/utmpx.h mlibc-workdir/sysdeps/fishos/include/abi-bits/utmpx.h
new file mode 120000
index 00000000..c6a26774
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/utmpx.h
@@ -0,0 +1 @@
+../../../../abis/linux/utmpx.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/utsname.h mlibc-workdir/sysdeps/fishos/include/abi-bits/utsname.h
new file mode 120000
index 00000000..b2857547
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/utsname.h
@@ -0,0 +1 @@
+../../../../abis/linux/utsname.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/vm-flags.h mlibc-workdir/sysdeps/fishos/include/abi-bits/vm-flags.h
new file mode 120000
index 00000000..bbe258cf
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/linux/vm-flags.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/vt.h mlibc-workdir/sysdeps/fishos/include/abi-bits/vt.h
new file mode 120000
index 00000000..5798a4ac
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/vt.h
@@ -0,0 +1 @@
+../../../../abis/linux/vt.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/wait.h mlibc-workdir/sysdeps/fishos/include/abi-bits/wait.h
new file mode 120000
index 00000000..feb2840c
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/wait.h
@@ -0,0 +1 @@
+../../../../abis/linux/wait.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/abi-bits/xattr.h mlibc-workdir/sysdeps/fishos/include/abi-bits/xattr.h
new file mode 120000
index 00000000..66412d70
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/abi-bits/xattr.h
@@ -0,0 +1 @@
+../../../../abis/linux/xattr.h
\ No newline at end of file
diff --git mlibc-clean/sysdeps/fishos/include/fishos/syscall.h mlibc-workdir/sysdeps/fishos/include/fishos/syscall.h
new file mode 100755
index 00000000..452c9021
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/fishos/syscall.h
@@ -0,0 +1,148 @@
+#ifndef SYSCALL_H
+#define SYSCALL_H
+
+#include <stdint.h>
+
+enum SyscallNum {
+    SYS_exit,
+    SYS_open,
+    SYS_mkdir,
+    SYS_close,
+    SYS_read,
+    SYS_pread,
+    SYS_write,
+    SYS_pwrite,
+    SYS_seek,
+    SYS_getcwd,
+    SYS_chdir,
+    SYS_mmap,
+    SYS_munmap,
+    SYS_fork,
+    SYS_execve,
+    SYS_sleep,
+    SYS_set_fs_base,
+    SYS_readdir,
+    SYS_unlink,
+    SYS_fcntl,
+    SYS_dup,
+    SYS_stat,
+    SYS_waitpid,
+    SYS_uname,
+    SYS_rename,
+    SYS_poll,
+    SYS_pipe,
+    SYS_readlink,
+    SYS_ioctl,
+    SYS_clock_gettime,
+    SYS_clock_getres,
+    SYS_socket,
+    SYS_socketpair,
+    SYS_bind,
+    SYS_connect,
+    SYS_listen,
+    SYS_accept,
+    SYS_recvmsg,
+    SYS_sendmsg,
+    SYS_shutdown,
+    SYS_link,
+    SYS_symlink,
+    SYS_thread_spawn,
+    SYS_thread_exit,
+    SYS_futex,
+    SYS_sigaltstack,
+    SYS_sigentry,
+    SYS_sigreturn,
+    SYS_sigmask,
+    SYS_sigaction,
+    SYS_kill,
+    SYS_gettid,
+    SYS_getpid,
+    SYS_getppid,
+    SYS_getpgid,
+    SYS_setpgid,
+    SYS_getsid,
+    SYS_setsid,
+    SYS_sysinfo,
+    SYS_mprotect,
+    SYS_getsockopt,
+    SYS_setsockopt,
+    SYS_getsockname,
+    SYS_getpeername,
+    SYS_fchdir,
+    SYS_umask,
+    SYS_thread_getname,
+    SYS_thread_setname,
+    SYS_inotify_create,
+    SYS_inotify_add_watch,
+    SYS_inotify_rm_watch,
+    SYS_sched_yield,
+    SYS_eventfd_create,
+    SYS_readv,
+    SYS_writev
+};
+
+#define SYSCALL_INLINE [[gnu::always_inline]] inline
+
+SYSCALL_INLINE uint64_t syscall(uint64_t sc) {
+    uint64_t ret;
+    asm volatile("syscall" : "=a" (ret)
+            : "a" (sc)
+            : "rcx", "r11", "memory");
+    return ret;
+}
+
+SYSCALL_INLINE uint64_t syscall(uint64_t sc, uint64_t arg1) {
+    uint64_t ret;
+    asm volatile("syscall" : "=a" (ret)
+            : "a" (sc), "D" (arg1)
+            : "rcx", "r11", "memory");
+    return ret;
+}
+
+SYSCALL_INLINE uint64_t syscall(uint64_t sc, uint64_t arg1, uint64_t arg2) {
+    uint64_t ret;
+    asm volatile("syscall" : "=a" (ret)
+            : "a" (sc), "D" (arg1), "S" (arg2)
+            : "rcx", "r11", "memory");
+    return ret;
+}
+
+SYSCALL_INLINE uint64_t syscall(uint64_t sc, uint64_t arg1, uint64_t arg2, uint64_t arg3) {
+    uint64_t ret;
+    asm volatile("syscall" : "=a" (ret)
+            : "a" (sc), "D" (arg1), "S" (arg2), "d" (arg3)
+            : "rcx", "r11", "memory");
+    return ret;
+}
+
+SYSCALL_INLINE uint64_t syscall(uint64_t sc, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4) {
+    uint64_t ret;
+    register uint64_t arg4_reg asm("r10") = arg4;
+    asm volatile("syscall" : "=a" (ret)
+            : "a" (sc), "D" (arg1), "S" (arg2), "d" (arg3), "r" (arg4_reg)
+            : "rcx", "r11", "memory");
+    return ret;
+}
+
+SYSCALL_INLINE uint64_t syscall(uint64_t sc, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5) {
+    uint64_t ret;
+    register uint64_t arg4_reg asm("r10") = arg4;
+    register uint64_t arg5_reg asm("r8")  = arg5;
+    asm volatile("syscall" : "=a" (ret)
+            : "a" (sc), "D" (arg1), "S" (arg2), "d" (arg3), "r" (arg4_reg), "r" (arg5_reg)
+            : "rcx", "r11", "memory");
+    return ret;
+}
+
+SYSCALL_INLINE uint64_t syscall(uint64_t sc, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6) {
+    uint64_t ret;
+    register uint64_t arg4_reg asm("r10") = arg4;
+    register uint64_t arg5_reg asm("r8")  = arg5;
+    register uint64_t arg6_reg asm("r9")  = arg6;
+    asm volatile("syscall" : "=a" (ret)
+            : "a" (sc), "D" (arg1), "S" (arg2), "d" (arg3), "r" (arg4_reg), "r" (arg5_reg), "r" (arg6_reg)
+            : "rcx", "r11", "memory");
+    return ret;
+}
+
+#endif
diff --git mlibc-clean/sysdeps/fishos/include/mlibc/thread-entry.hpp mlibc-workdir/sysdeps/fishos/include/mlibc/thread-entry.hpp
new file mode 100644
index 00000000..2dd88a64
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/mlibc/thread-entry.hpp
@@ -0,0 +1,10 @@
+#pragma once
+
+#include <mlibc/tcb.hpp>
+
+extern "C" void __mlibc_start_thread(void);
+extern "C" void __mlibc_enter_thread(void *entry, void *user_arg, Tcb *tcb);
+
+namespace mlibc {
+	void *prepare_stack(void *entry, void *user_arg, void *tcb);
+}
diff --git mlibc-clean/sysdeps/fishos/include/mntent.h mlibc-workdir/sysdeps/fishos/include/mntent.h
new file mode 100644
index 00000000..bafd289e
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/mntent.h
@@ -0,0 +1,50 @@
+#ifndef _MNTENT_H
+#define _MNTENT_H
+
+#include <stdio.h>
+
+// TODO: Refer to _PATH_MOUNTED
+#define MOUNTED "/etc/mtab"
+
+/* Generic mount options */
+#define MNTOPT_DEFAULTS "defaults"		/* Use all default options. */
+#define MNTOPT_RO       "ro"			/* Read only. */
+#define MNTOPT_RW       "rw"			/* Read/write. */
+#define MNTOPT_SUID     "suid"			/* Set uid allowed. */
+#define MNTOPT_NOSUID   "nosuid"		/* No set uid allowed. */
+#define MNTOPT_NOAUTO   "noauto"		/* Do not auto mount. */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct mntent {
+	char *mnt_fsname;
+	char *mnt_dir;
+	char *mnt_type;
+	char *mnt_opts;
+	int mnt_freq;
+	int mnt_passno;
+};
+
+#ifndef __MLIBC_ABI_ONLY
+
+FILE *setmntent(const char *, const char *);
+
+struct mntent *getmntent(FILE *);
+
+int addmntent(FILE *, const struct mntent *);
+
+int endmntent(FILE *);
+
+char *hasmntopt(const struct mntent *, const char *);
+
+struct mntent *getmntent_r(FILE *, struct mntent *,  char *, int);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _MNTENT_H
diff --git mlibc-clean/sysdeps/fishos/include/sys/mount.h mlibc-workdir/sysdeps/fishos/include/sys/mount.h
new file mode 100644
index 00000000..b19f3d7e
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/sys/mount.h
@@ -0,0 +1,54 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MS_RDONLY 1
+#define MS_NOSUID 2
+#define MS_NODEV 4
+#define MS_NOEXEC 8
+#define MS_SYNCHRONOUS 16
+#define MS_REMOUNT 32
+#define MS_MANDLOCK 64
+#define MS_DIRSYNC 128
+#define MS_NOSYMFOLLOW 256
+#define MS_NOATIME 1024
+#define MS_NODIRATIME 2048
+#define MS_BIND 4096
+#define MS_MOVE 8192
+#define MS_REC 16384
+#define MS_SILENT 32768
+#define MS_POSIXACL (1 << 16)
+#define MS_UNBINDABLE (1 << 17)
+#define MS_PRIVATE (1 << 18)
+#define MS_SLAVE (1 << 19)
+#define MS_SHARED (1 << 20)
+#define MS_RELATIME (1 << 21)
+#define MS_KERNMOUNT (1 << 22)
+#define MS_I_VERSION (1 << 23)
+#define MS_STRICTATIME (1 << 24)
+#define MS_LAZYTIME (1 << 25)
+#define MS_NOREMOTELOCK (1 << 27)
+#define MS_NOSEC (1 << 28)
+#define MS_BORN (1 << 29)
+#define MS_ACTIVE (1 << 30)
+#define MS_NOUSER (1 << 31)
+
+#define MNT_FORCE 1
+
+#ifndef __MLIBC_ABI_ONLY
+
+int mount(const char *source, const char *target,
+		const char *fstype, unsigned long flags, const void *data);
+int umount(const char *target);
+int umount2(const char *target, int flags);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _SYS_MOUNT_H
diff --git mlibc-clean/sysdeps/fishos/include/sys/reboot.h mlibc-workdir/sysdeps/fishos/include/sys/reboot.h
new file mode 100644
index 00000000..6c4e4959
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/sys/reboot.h
@@ -0,0 +1,20 @@
+#ifndef MLIBC_SYS_REBOOT_H
+#define MLIBC_SYS_REBOOT_H
+
+#include <abi-bits/reboot.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __MLIBC_ABI_ONLY
+
+int reboot(int arg);
+
+#endif /* !__MLIBC_ABI_ONLY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // MLIBC_SYS_REBOOT_H
diff --git mlibc-clean/sysdeps/fishos/include/sys/sysmacros.h mlibc-workdir/sysdeps/fishos/include/sys/sysmacros.h
new file mode 100644
index 00000000..2d696e31
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/include/sys/sysmacros.h
@@ -0,0 +1,33 @@
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static unsigned int __mlibc_dev_major(
+		unsigned long long int __dev) {
+  return ((__dev >> 8) & 0xfff) | ((unsigned int)(__dev >> 32) & ~0xfff);
+}
+
+static unsigned int __mlibc_dev_minor(
+		unsigned long long int __dev) {
+  return (__dev & 0xff) | ((unsigned int)(__dev >> 12) & ~0xff);
+}
+
+static unsigned long long int __mlibc_dev_makedev(
+		unsigned int __major, unsigned int __minor) {
+  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
+	  | (((unsigned long long int)(__minor & ~0xff)) << 12)
+	  | (((unsigned long long int)(__major & ~0xfff)) << 32));
+}
+
+#define major(dev) __mlibc_dev_major(dev)
+#define minor(dev) __mlibc_dev_minor(dev)
+#define makedev(major, minor) __mlibc_dev_makedev(major, minor)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _SYS_SYSMACROS_H
diff --git mlibc-clean/sysdeps/fishos/meson.build mlibc-workdir/sysdeps/fishos/meson.build
new file mode 100644
index 00000000..1d1ead03
--- /dev/null
+++ mlibc-workdir/sysdeps/fishos/meson.build
@@ -0,0 +1,133 @@
+sysdep_supported_options = {
+	'posix': true,
+	'linux': true,
+	'glibc': true,
+	'bsd': true,
+}
+
+rtld_dso_sources += files(
+	'generic/generic.cpp',
+	'generic/filesystem.cpp',
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+	'generic/generic.cpp',
+	'generic/filesystem.cpp',
+	'generic/socket.cpp',
+	'generic/thread.cpp',
+	'generic/thread_entry.S'
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/access.h',
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/statx.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/reboot.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/limits.h',
+		'include/abi-bits/utsname.h',
+		'include/abi-bits/ptrace.h',
+		'include/abi-bits/poll.h',
+		'include/abi-bits/epoll.h',
+		'include/abi-bits/packet.h',
+		'include/abi-bits/inotify.h',
+		'include/abi-bits/clockid_t.h',
+		'include/abi-bits/ipc.h',
+		'include/abi-bits/shm.h',
+		'include/abi-bits/mqueue.h',
+		'include/abi-bits/suseconds_t.h',
+		'include/abi-bits/fsfilcnt_t.h',
+		'include/abi-bits/fsblkcnt_t.h',
+		'include/abi-bits/socklen_t.h',
+		'include/abi-bits/statfs.h',
+		'include/abi-bits/statvfs.h',
+		'include/abi-bits/ioctls.h',
+		'include/abi-bits/xattr.h',
+		'include/abi-bits/msg.h',
+		'include/abi-bits/vt.h',
+		'include/abi-bits/random.h',
+		'include/abi-bits/rlim_t.h',
+		'include/abi-bits/sigval.h',
+		'include/abi-bits/sigevent.h',
+		'include/abi-bits/utmpx.h',
+		'include/abi-bits/utmp-defines.h',
+		subdir: 'abi-bits',
+		follow_symlinks: true
+	)
+
+	install_headers(
+		'include/sys/reboot.h',
+		'include/sys/mount.h',
+		'include/sys/sysmacros.h',
+		subdir: 'sys',
+	)
+
+	install_headers(
+		'include/mntent.h',
+	)
+	
+	install_headers(
+		'include/fishos/syscall.h',
+		subdir: 'fishos'
+	)
+endif
+
+if not headers_only
+	crt = custom_target(
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: files('crt-' + host_machine.cpu_family() / 'crt1.S'),
+		output: 'crt1.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	crt_pie = custom_target(
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: files('crt-' + host_machine.cpu_family() / 'Scrt1.S'),
+		output: 'Scrt1.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target(
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: files('crt-' + host_machine.cpu_family() / 'crti.S'),
+		output: 'crti.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target(
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: files('crt-' + host_machine.cpu_family() / 'crtn.S'),
+		output: 'crtn.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
diff --git mlibc-clean/tests/ansi/sscanf.c mlibc-workdir/tests/ansi/sscanf.c
index 48716617..512b45ec 100644
--- mlibc-clean/tests/ansi/sscanf.c
+++ mlibc-workdir/tests/ansi/sscanf.c
@@ -174,6 +174,44 @@ int main() {
 		assert(!strcmp(name, "SomeOption"));
 	}
 
+	{
+		// From openjdk
+#define RANGEBASE_ASCII "\x1\x2\x3\x4\x5\x6\x7\x8\xa\xb\xc\xd\xe\xf" \
+    "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f" \
+    "\x21\x22\x23\x24\x25\x26\x27\x2a\x2b\x2c\x2d" \
+    "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f" \
+    "\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f" \
+    "\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5c\x5e\x5f" \
+    "\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f" \
+    "\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
+
+#define RANGEBASE_NON_ASCII "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f" \
+    "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f" \
+    "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf" \
+    "\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf" \
+    "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf" \
+    "\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf" \
+    "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+
+#define RANGEBASE RANGEBASE_ASCII RANGEBASE_NON_ASCII
+
+#define RANGE0 "[*" RANGEBASE "]"
+#define RANGESLASH "[*" RANGEBASE "/]"
+		char buf[] = "* *";
+		char str1[256] = {0};
+		char str2[256] = {0};
+
+		int bytes_read1 = 0;
+		sscanf(buf, "%*[ \t]%n", &bytes_read1);
+
+		int bytes_read2 = 0;
+		int ret = sscanf(buf, "%255" RANGESLASH "%*[ ]" "%255"  RANGE0 "%n", str1, str2, &bytes_read2);
+		assert(ret == 2);
+		assert(!strcmp(str1, "*"));
+		assert(!strcmp(str2, "*"));
+		assert(bytes_read2 == 3);
+	}
+
 	test_matrix();
 
 #pragma GCC diagnostic push
